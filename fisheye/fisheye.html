<!DOCTYPE html>
<html class="ocks-org do-not-copy">
<meta charset="utf-8">
<title>Fisheye Distortion</title>
<style>

@import url(./style.css?aea6f0a);

/* #chart1 {
  width: 960px;
  height: 500px;
  border: solid 1px #ccc;
} */

p {
  font-size: 20px;
}

text {
  font-size: 14px;
  font-family: 'Roboto';
}

.background {
  fill: none;
  pointer-events: all;
}

#chart2, #chart3 {
  width: 960px;
  height: 180px;
  border: solid 1px #ccc;
}

#chart2 path, #chart3 line {
  fill: none;
  stroke: #333;
}

#chart3 line {
  shape-rendering: crispEdges;
}

#chart1, #chart4 {
  margin-left: -40px;
  height: 506px;
}

#chart4 .background {
  fill: #d0d0d0;
}

#chart1 .background {
  fill: #d0d0d0;
}
#chart1 line {
  stroke: #fff;
}

#chart4 .dot {
  stroke: #444;
  stroke-width: 1.8px;
}

#chart1 .dot {
  stroke: #444;
  stroke-width: 1.8px
}

.axis path, .axis line {
  fill: none;
  stroke: #fff;
  shape-rendering: crispEdges;
}

</style>

<header>
  <aside>December 10, 2018</aside>
  <a href="https://github.com/jackfletch/computer-graphics-final" rel="author">Drew Baker and Jack Fletcher</a>
</header>
<body>
  <h1>Fisheye Distortion</h1>
  <p>
    It can be difficult to observe micro and macro features simultaneously with complex graphs.
    If you zoom in for detail, the graph is too big to view in its entirety.
    If you zoom out to see the overall structure, small details are lost.
    <a href="http://infovis-wiki.net/wiki/Focus-plus-Context">Focus + context</a>
    techniques allow interactive exploration of an area of interest (the <i>focus</i>) in greater detail,
    while preserving the surrounding environment (the <i>context</i>).
  </p>
  <p id="chart1"></p>
  <p>
    In the graph above, <b>fisheye distortion</b> magnifies the local region around the mouse,
    while leaving the larger graph unaffected for context. The localized, circular nature of the distortion
    can be seen clearly by applying it to a uniform grid:
  </p>
  <p id="chart2"></p>
  <p>
    This type of distortion is particularly useful for disambiguating edge-crossings in static network layouts:
    edges between distant nodes are distorted more strongly than local ones.
  </p>
  <h2><a name="cartesian" href="#cartesian">#</a>Cartesian Distortion</h2>
  <p>
    Circular fisheye is only one of many possible distortion functions.
    Two disadvantages of circular distortion are that it compresses (rather than magnifies)
    the area near the circumference of the circle, and that it requires curved grid lines to show the distortion accurately.
    The latter makes it unsuitable for visualizations that have quantitative position encodings, such as scatterplots.
  </p>
  <p>
    <a href="http://dl.acm.org/citation.cfm?id=142763">Sarkar and Brown</a> recommend
    a different function that magnifies continuously so as to avoid local minification.
    Furthermore, they demonstrate applying the distortion to each dimension separately, resulting in <i>Cartesian distortion</i>:
  </p>
  <p id="chart3"></p>
  <p>
    With this technique, straight lines parallel to the <i>x</i> or <i>y</i> axis remain straight even after distortion.
    This means you can use standard axes in conjunction with fisheye distortion in scatterplots:
  </p>
  <p id="chart4"></p>
  <p>
    Fisheye distortion allows you to zoom into small areas of the chart without losing sense of the overall distribution.
    With distortion, you can easily differentiate individual countries while retaining context.
  </p>
  <h2><a name="implementation" href="#implementation">#</a>Implementation</h2>
  <p>
    These examples use D3’s <a href="https://github.com/d3/d3-plugins/tree/master/fisheye">fisheye plugin</a>,
    which supports both circular and Cartesian distortion.
    The latter is implemented on top of D3’s <a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales">quantitative scales</a>,
    allowing distortion of linear, logarithmic, and exponential scales, as well as compatibility with D3’s
    <a href="https://github.com/mbostock/d3/wiki/SVG-Axes">axis component</a>. For additional implementations,
    see <a href="http://flare.prefuse.org">Flare</a> and <a href="http://sigmajs.org">Sigma.js</a>.
  </p>
</body>
<footer>
  <aside>December 10, 2018</aside>
  <a href="https://github.com/jackfletch/computer-graphics-final" rel="author">Drew Baker and Jack Fletcher</a>
</footer>

<script src="http://d3js.org/d3.v2.js" charset="utf-8"></script>
<script src="fisheye.js"></script>
<script>
  
(function chart1() {
  // Various accessors that specify the four dimensions of data to visualize.
  function x(d) { return d.followers; }
  function y(d) { return d.following; }
  function radius(d) { return d.tweets; }
  function color(d) { return d.movieName; }

  // Chart dimensions.
  var margin = {top: 5.5, right: 19.5, bottom: 12.5, left: 39.5},
      width = 960,
      height = 500 - margin.top - margin.bottom;

  // Various scales and distortions.
  var xScale = d3.scale.log().domain([1e1, 1e8]).range([0, width]),
      yScale = d3.scale.log().domain([1, 1e4]).range([height, 0]),
      radiusScale = d3.scale.sqrt().domain([0, 50000]).range([2, 50]),
      colorScale = d3.scale.category10().domain([
        "Creed II",
        "Avengers: Infinity War",
        "Star Wars: The Last Jedi",
        "The Hunger Games: Catching Fire",
        "Toy Story 3",
        "Shrek 2",
        "Breaking Bad",
        "Deadpool 2",
        "Dunkirk",
        "Caddyshack",
        "Furious 7"
      ]);

  var fisheye = d3.fisheye.circular()
    .distortion(3.5)
    .radius(120);

  // The x & y axes.
  var xAxis = d3.svg.axis()
    .orient("bottom")
    .scale(xScale)
    .tickFormat(d => formatTick(d))
    .tickSize(-height);
    var yAxis = d3.svg.axis()
    .orient("left")
    .scale(yScale)
    .tickFormat(d => formatTick(d))
    .tickSize(-width);

  // Create the SVG container and set the origin.
  var svg = d3.select("#chart1").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  // Add a background rect for mousemove.
  svg.append("rect")
      .attr("class", "background")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);

  // Add the y-axis.
  svg.append("g")
      .attr("class", "y axis")
      .call(yAxis);

  // Add an x-axis label.
  svg.append("text")
      .attr("class", "x label")
      .attr("text-anchor", "end")
      .attr("x", width - 6)
      .attr("y", height - 6)
      .text("number of followers");

  // Add a y-axis label.
  svg.append("text")
      .attr("class", "y label")
      .attr("text-anchor", "end")
      .attr("x", -6)
      .attr("y", 6)
      .attr("dy", ".75em")
      .attr("transform", "rotate(-90)")
      .text("number of people followed by individual");

  // Load the data.
  d3.json("../../data/actorsData.json", function(actors) {

    // Add a dot per nation. Initialize the data at 1800, and set the colors.
    var dot = svg.append("g")
        .attr("class", "dots")
      .selectAll(".dot")
        .data(actors)
      .enter().append("circle")
        .attr("class", "dot")
        .style("fill", function(d) { return colorScale(color(d)); })
        .attr("x", function (d) { return d.followers})
        .attr("y", function (d) { return d.following})
        .call(position)
        .sort(function(a, b) { return radius(b) - radius(a); });

    dot.forEach(function (d) {
      d.x = d.followers;
      d.y = d.following;
    })

    // Add a title.
    function getTitle(d) {
      return `Name: ${d.name}\n` +
        `Production: ${d.movieName}\n` +
        `Followers: ${d.followers}\n` +
        `Following: ${d.following}\n` +
        `Tweets: \t${d.tweets}`;
    }

    dot.append("title")
      .text(d => getTitle(d));

    // Positions the dots based on data.
    function position(dot) {
      dot.attr("cx", function(d) { return xScale(x(d)); })
        .attr("cy", function(d) { return yScale(y(d)); })
        .attr("r", function(d) { return radiusScale(radius(d)); });
    }

    var actorPoints = svg.selectAll(".dot");

    svg.on("mousemove", function() {
      fisheye.focus(d3.mouse(this));

      actorPoints.each(function(d) {
        d.x = xScale(d.followers);
        d.y = yScale(d.following);
        d.fisheye = fisheye(d);
      })
        .attr("cx", function (d) { return d.fisheye.x; })
        .attr("cy", function (d) { return d.fisheye.y; })
        .attr("r", function (d) { return radiusScale(d.fisheye.z * radius(d)); });
    });
  });
})();

(function chart2() {
  var width = 960,
      height = 180,
      xStepsBig = d3.range(10, width, 16),
      yStepsBig = d3.range(10, height, 16),
      xStepsSmall = d3.range(0, width + 6, 6),
      yStepsSmall = d3.range(0, height + 6, 6);

  var fisheye = d3.fisheye.circular()
      .focus([360, 90])
      .radius(100);

  var line = d3.svg.line();

  var svg = d3.select("#chart2").append("svg")
      .attr("width", width)
      .attr("height", height)
    .append("g")
      .attr("transform", "translate(-.5,-.5)");

  svg.append("rect")
      .attr("class", "background")
      .attr("width", width)
      .attr("height", height);

  svg.selectAll(".x")
      .data(xStepsBig)
    .enter().append("path")
      .attr("class", "x")
      .datum(function(x) { return yStepsSmall.map(function(y) { return [x, y]; }); });

  svg.selectAll(".y")
      .data(yStepsBig)
    .enter().append("path")
      .attr("class", "y")
      .datum(function(y) { return xStepsSmall.map(function(x) { return [x, y]; }); });

  var path = svg.selectAll("path")
      .attr("d", fishline);

  svg.on("mousemove", function() {
    fisheye.focus(d3.mouse(this));
    path.attr("d", fishline);
  });

  function fishline(d) {
    return line(d.map(function(d) {
      d = fisheye({x: d[0], y: d[1]});
      return [d.x, d.y];
    }));
  }
})();

(function chart3() {
  var width = 960,
      height = 180,
      xSteps = d3.range(10, width, 16),
      ySteps = d3.range(10, height, 16);

  var xFisheye = d3.fisheye.scale(d3.scale.identity).domain([0, width]).focus(360),
      yFisheye = d3.fisheye.scale(d3.scale.identity).domain([0, height]).focus(90);

  var svg = d3.select("#chart3").append("svg")
      .attr("width", width)
      .attr("height", height)
    .append("g")
      .attr("transform", "translate(-.5,-.5)");

  svg.append("rect")
      .attr("class", "background")
      .attr("width", width)
      .attr("height", height);

  var xLine = svg.selectAll(".x")
      .data(xSteps)
    .enter().append("line")
      .attr("class", "x")
      .attr("y2", height);

  var yLine = svg.selectAll(".y")
      .data(ySteps)
    .enter().append("line")
      .attr("class", "y")
      .attr("x2", width);

  redraw();

  svg.on("mousemove", function() {
    var mouse = d3.mouse(this);
    xFisheye.focus(mouse[0]);
    yFisheye.focus(mouse[1]);
    redraw();
  });

  function redraw() {
    xLine.attr("x1", xFisheye).attr("x2", xFisheye);
    yLine.attr("y1", yFisheye).attr("y2", yFisheye);
  }
})();

(function chart4() {

  // Various accessors that specify the four dimensions of data to visualize.
  function x(d) { return d.followers; }
  function y(d) { return d.following; }
  function radius(d) { return d.tweets; }
  function color(d) { return d.movieName; }

  // Chart dimensions.
  var margin = {top: 5.5, right: 19.5, bottom: 12.5, left: 39.5},
      width = 960,
      height = 500 - margin.top - margin.bottom;

  // Various scales and distortions.
  var xScale = d3.fisheye.scale(d3.scale.log).domain([1e1, 1e8]).range([0, width]),
      yScale = d3.fisheye.scale(d3.scale.log).domain([1, 1e4]).range([height, 0]),
      radiusScale = d3.scale.sqrt().domain([0, 50000]).range([2, 40]),
      colorScale = d3.scale.category10().domain(["Creed II", "Avengers: Infinity War", 
        "Star Wars: The Last Jedi", "The Hunger Games: Catching Fire", "Toy Story 3", 
        "Shrek 2", "Breaking Bad", "Deadpool 2", "Dunkirk", "Caddyshack", "Furious 7"]);

  // The x & y axes.
  var xAxis = d3.svg.axis().orient("bottom").scale(xScale).tickSize(-height).tickFormat(d => formatTick(d)),
      yAxis = d3.svg.axis().scale(yScale).orient("left").tickSize(-width).tickFormat(d => formatTick(d));

  // Create the SVG container and set the origin.
  var svg = d3.select("#chart4").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  // Add a background rect for mousemove.
  svg.append("rect")
      .attr("class", "background")
      .attr("width", width)
      .attr("height", height);

  // Add the x-axis.
  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);

  // Add the y-axis.
  svg.append("g")
      .attr("class", "y axis")
      .call(yAxis);

  // Add an x-axis label.
  svg.append("text")
      .attr("class", "x label")
      .attr("text-anchor", "end")
      .attr("x", width - 6)
      .attr("y", height - 6)
      .text("number of followers");

  // Add a y-axis label.
  svg.append("text")
      .attr("class", "y label")
      .attr("text-anchor", "end")
      .attr("x", -6)
      .attr("y", 6)
      .attr("dy", ".75em")
      .attr("transform", "rotate(-90)")
      .text("number of people followed by individual");

  // Load the data.
  d3.json("../../data/actorsData.json", function(actors) {

    // Add a dot per nation. Initialize the data at 1800, and set the colors.
    var dot = svg.append("g")
        .attr("class", "dots")
      .selectAll(".dot")
        .data(actors)
      .enter().append("circle")
        .attr("class", "dot")
        .style("fill", function(d) { return colorScale(color(d)); })
        .call(position)
        .sort(function(a, b) { return radius(b) - radius(a); });

    // Add a title.
    dot.append("title")
        .text(function(d) { return "Name: " + d.name 
                                  + "\nProduction: " + d.movieName
                                  + "\nFollowers: " + numberWithCommas(d.followers) 
                                  + "\nFollowing: " + numberWithCommas(d.following)
                                  + "\nTweets: " + numberWithCommas(d.tweets); });

    // Positions the dots based on data.
    function position(dot) {
      dot .attr("cx", function(d) { return xScale(x(d)); })
          .attr("cy", function(d) { return yScale(y(d)); })
          .attr("r", function(d) { return radiusScale(radius(d)); });
    }

    svg.on("mousemove", function() {
      var mouse = d3.mouse(this);
      xScale.distortion(2.5).focus(mouse[0]);
      yScale.distortion(2.5).focus(mouse[1]);

      dot.call(position);
      svg.select(".x.axis").call(xAxis);
      svg.select(".y.axis").call(yAxis);
    });
  });
})();
</script>
